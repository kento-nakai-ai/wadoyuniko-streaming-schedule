Claude Code完全ガイド｜AI開発者が全自動コーディングを実現する方法


🚀 開発現場に革命が起きている
「朝起きたら、昨夜依頼したプルリクエストが完成している」

そんな夢のような体験が、2025年の開発現場では当たり前になりつつあります。

Anthropic社が5月22日に正式リリースした「Claude Code」は、単なるコーディング支援ツールではありません。7時間連続でコーディングを続け、複雑なリファクタリングを人間の介入なしに完遂する、真の意味での「AI開発パートナー」です。

実際に、SWE-benchという業界標準ベンチマークで**72.5%**というスコアを記録し、OpenAIのGPT-4.1（54.6%）を大幅に上回りました。これは単なる数字ではありません。プロダクションレベルのコードを自律生成できることを証明した歴史的瞬間なのです。

💡 なぜ今、Claude Codeなのか？
従来のAIコーディングツールの限界
これまでのAI支援ツールは、確かに便利でした。しかし、以下のような課題がありました：

対象ファイルを明示的に指定する必要

単発のコード生成に留まる

プロジェクト全体の文脈を理解できない

複数ファイルにまたがる作業は人間が管理

Claude Codeが実現する「真の自動化」
Claude Codeは、これらの課題を根本的に解決しました：

🎯 プロジェクト自動解析 プロジェクトディレクトリの構造を自動で把握し、必要なファイルを自律的に特定・処理します。

🔄 エンドツーエンド自動化 「株価分析アプリを作って」という抽象的な指示から、設計・実装・テスト・Git操作まで一貫して実行します。

⚡ 超長時間集中力 人間のエンジニアでも集中力を保つのが困難な7時間以上の連続作業を、品質を落とすことなく継続できます。

🏢 組織レベルでの開発効率最大化戦略
2025年7月の最新アップデートが変えたもの
Claude Codeの真の価値は、個人の生産性向上だけではありません。組織全体の開発プロセスを根本的に変革することにあります。

Hooks機能による完全自動化

claude hooks add pre "npm run lint"     # コード変更前の自動検証
claude hooks add post "pytest -q"        # 実装後の自動テスト
claude hooks add notify "curl -X POST $WEBHOOK_URL" # 完了通知

copy
CI/CD完全統合 GitHub ActionsやSlack/Discord Webhookとの連携により、人間が寝ている間も開発が進行します。

VSCode統合による思考可視化 Reasoning Paneで、Claude Codeの思考ステップをリアルタイムで可視化。チーム全体でAIの判断プロセスを共有できます。

実際の導入効果
某IT企業での事例

仕様変更対応の手間が70%削減

コミットミスが1/3以下に減少

開発効率が300%向上

製造業での事例

助成金を活用した低コスト導入

初月からROIを実感

🎯 戦略的導入のポイント
段階的アプローチ
フェーズ1：個人レベルでの習熟 まずは簡単なタスクから始めて、Claude Codeの思考パターンを理解します。

フェーズ2：チーム連携の構築 CLAUDE.mdファイルによるプロジェクト固有の指示共有で、チーム全体の出力品質を統一します。

フェーズ3：組織全体の自動化 Hooks機能とCI/CD統合により、組織レベルでの開発プロセス自動化を実現します。

コスト最適化戦略
開発初期・PoC段階 Claude Sonnet 4を中心とした従量課金で、数ドル〜十数ドル程度の低コストで開始。

本格運用段階 Claude Maxプラン（月額$100）で、安定した高パフォーマンスを実現。

「思ったよりたくさん使えた」という声が多数報告されており、ROIは初月から実感できるレベルです。

⚠️ 重要な警告：今すぐ行動すべき理由
AIツールの進化スピードは、私たちの想像を遥かに超えています。

Claude Codeのような革新的ツールを単体で導入するだけでは、真の競争優位は築けません。

重要なのは：

組織全体のAIリテラシー向上

戦略的活用法の習得

チーム全体での継続的な改善

今行動を起こすか、競合他社に置いていかれるかの分岐点に立っているのです。

🔥 次回予告：完全攻略法を公開
この記事では、Claude Codeの革命的な可能性をお伝えしました。

ここから先の有料記事では、実践的内容を完全公開します：

AI開発の未来を先取りしたい方は、ぜひ続きをお読みください。

この記事は2025年8月10日時点の最新情報を基に作成されています。Claude Codeの機能は急速に進化しているため、最新情報は公式ドキュメントもご確認ください。

全最新の全自動コーディングの全て
というタイトルが一番読んで欲しい部分です。


目次
🚀 開発現場に革命が起きている
💡 なぜ今、Claude Codeなのか？
従来のAIコーディングツールの限界
Claude Codeが実現する「真の自動化」
🏢 組織レベルでの開発効率最大化戦略
2025年7月の最新アップデートが変えたもの
実際の導入効果
🎯 戦略的導入のポイント
段階的アプローチ
コスト最適化戦略

すべて表示
ここから先は有料部分になります。

ここから先は有料部分です
まずは初心者向けの20ドルのProプランの導入方法から解説します。

Claude Code 20ドルProプラン 完全導入ガイド
🎉 朗報：2025年6月5日からProプランで利用可能！
Claude Code が月額**$20のProプラン**で利用できるようになりました！従来は$100-200のMaxプラン限定でしたが、個人開発者にも手が届きやすくなりました。

💰 料金比較
プラン 月額料金 Claude Code 利用可能モデル 制限 Pro $20 (約3,000円) ✅ 利用可能 Claude Sonnet 4 5時間ごと10-40プロンプト Max 5x $100 (約15,000円) ✅ 利用可能 Sonnet 4 + Opus 4 5時間ごと50-200プロンプト Max 20x $200 (約30,000円) ✅ 利用可能 Sonnet 4 + Opus 4 5時間ごと200-800プロンプト

結論：個人開発・小規模プロジェクトならProプランで十分！

🚀 セットアップ手順
Step 1: Claude Proプランへの加入
1-1. アカウント作成

# Claude.ai にアクセス
https://claude.ai/

# Googleアカウントでサインアップ（推奨）

copy
1-2. Proプランにアップグレード

# ログイン後、右上の「Upgrade」をクリック
# Proプラン（$20/月）を選択
# 支払い情報を入力

# 💡 Tips: 年間契約は割安だが、まずは月契約で試すのが安全

copy
1-3. 契約管理（重要）

# 契約後すぐに自動更新をオフにする方法：
# 設定 → 請求 → プランを調整 → 解約

# ⚠️ 注意：解約しても支払済み1ヶ月分は利用可能
# 気に入ったら再契約すればOK

copy
Step 2: 環境準備
macOS の場合

# Node.js がインストール済みか確認
node -v
npm -v

# インストールされていない場合
# https://nodejs.org/ からダウンロードしてインストール

copy
Windows の場合（WSL2必須）

WSL2のインストール（PowerShellを管理者権限で実行）

# Windows 機能の有効化
dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart

# または簡単コマンド（Windows 10 version 2004以降）
wsl --install

# 再起動後、Ubuntu をインストール
wsl --install -d Ubuntu

copy
Ubuntu初期設定

# WSL Ubuntu起動後
# ユーザー名とパスワードを設定

# パッケージ更新
sudo apt update && sudo apt upgrade -y
sudo apt install -y curl wget build-essential git

# Node.js のインストール（nvmを使用）
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash

# ターミナル再起動後
nvm install 22.16.0
nvm use 22.16.0

# バージョン確認
node -v  # v22.16.0
npm -v   # 10.8.1

copy
Linux (Ubuntu/Debian) の場合

# Node.js インストール
curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash -
sudo apt-get install -y nodejs

# バージョン確認
node -v
npm -v

copy
Step 3: Claude Code インストール
3-1. Claude Code のインストール

# NPM からインストール
npm install -g @anthropic-ai/claude-code

# Windows WSL の場合は追加オプションが必要
npm config set os linux
npm install -g @anthropic-ai/claude-code --force --no-os-check

# インストール確認
claude -v
# Claude Code 1.0.41 (または最新版)

copy
3-2. 初回セットアップ

# 作業ディレクトリに移動
mkdir claude-test
cd claude-test

# Claude Code 起動
claude

copy
3-3. 認証設定

# 初回起動時に認証画面が表示される
# 表示スタイルを選択（推奨：デフォルト）

# ブラウザが開くので Claude.ai アカウントでログイン
# Proプランのアカウントでログインすることが重要

# 認証完了後、ターミナルに戻る

copy
🎯 使用開始手順
基本的な使い方
# Claude Code 起動
claude

# 基本的な会話
"こんにちは、Claude Code です！何をお手伝いしましょうか？"

# プロジェクト作成例
"シンプルなto-doアプリを作成してください"

# ファイル編集例
"このJavaScriptファイルにエラーハンドリングを追加して"

copy
便利なコマンド
# 使用可能なコマンド一覧
/help

# 会話履歴のクリア（重要：トークン節約）
/clear

# モデルの切り替え（Proプランでは Sonnet 4 のみ）
/model

# 設定確認
/config

# 使用量確認
/cost

# 終了
/exit

copy
💡 Proプラン最適化テクニック
トークン効率化の方法
1. 短いプロンプトを心がける

❌ 悪い例：
"このReactコンポーネントを完全に書き直して、最新のReact 18の機能を使って、TypeScriptで型安全にして、パフォーマンスも向上させて、テストも追加して..."

✅ 良い例：
"このコンポーネントをTypeScriptに変換して"
"パフォーマンス改善のため useMemo を追加"
"単体テストを作成して"

copy
2. /clear を活用

# 新しいタスクを開始する前に必ず実行
/clear

# 理由：会話履歴が長くなるとトークン消費が激増

copy
3. ファイルを分割して処理

❌ 悪い例：
"この1000行のファイル全体を修正して"

✅ 良い例：
"まず関数A部分のみを修正して"
"次に関数B部分を修正して"

copy
制限内での効率的活用
Proプランの制限

5時間ごとに10-40プロンプト

Claude Sonnet 4のみ利用可能

小規模コードベース推奨（1-2時間のコーディング）

効率的な利用パターン

# 1日の理想的な使用パターン
09:00-10:00 - 朝の作業（10プロンプト）
14:00-15:00 - 午後の作業（15プロンプト）
19:00-20:00 - 夜の作業（10プロンプト）

# 合計：35プロンプト/日 = 制限内で十分活用可能

copy
🔧 VSCode統合設定
Claude Code拡張機能のインストール
# VSCode Extensions から検索してインストール
"Claude Code"

# または、VSCode内で：
Ctrl+Shift+P → "Extensions: Install Extensions"
→ "Claude Code" で検索してインストール

copy
統合後の使い方
# VSCode内でClaude Codeパネルを開く
Ctrl+Shift+P → "Claude Code: Open"

# または
View → Terminal → 新しいターミナル → "claude" と入力

copy
💸 コスト管理
使用量の確認方法
# Claude Code内でコスト確認
/cost

# 表示例：
Session cost: $2.39
Total monthly cost: $15.47
Remaining budget: $4.53

copy
ccusage ツールの導入（推奨）
# より詳細なコスト分析ツール
npm install -g ccusage

# 使用方法
ccusage

# 詳細分析レポートが表示される

copy
コスト削減のコツ
# 1. 短時間集中セッション
- 1回のセッションは30分以内
- 明確な目標を設定してから開始

# 2. プリプランニング
- 事前に作業内容を整理
- 必要なファイルを特定

# 3. バッチ処理
- 似たような作業をまとめて実行
- 同じファイルの修正は一度に完了

# 4. 定期的な /clear
- 長い会話履歴を避ける
- 新しいタスク開始時は必ずクリア

copy
📊 実際の使用感（体験レポート）
テトリスゲーム作成例
使用プロンプト数: 15個
作業時間: 45分
作成内容:
- HTML/CSS/JavaScript でテトリス実装
- 基本的なゲームロジック
- スコア機能
- キーボード操作

結果: 完全に動作するゲームが完成
コスト: 約$2.50相当

copy
Webアプリ機能追加例
使用プロンプト数: 25個
作業時間: 1.5時間
作業内容:
- 既存アプリへの認証機能追加
- データベース設計修正
- フロントエンド UI 更新
- テスト作成

結果: プロダクション準備完了
累計コスト: 約$22.44（制限到達）

copy
⚠️ 注意点と制限事項
制限に達した場合
# レート制限メッセージ例：
"Rate limit reached. Please try again in 3 hours 15 minutes."

# 対処法：
1. 時間をおいて再度試行
2. 作業を分割して効率化
3. 必要に応じてMaxプランへアップグレード検討

copy
システム要件
macOS: 10.15以上

Linux: Ubuntu 20.04以上/Debian 10以上

Windows: WSL2必須

Node.js: v18以上推奨

メモリ: 最低4GB

セキュリティ注意事項
# 機密情報の扱い
- APIキーや秘密鍵をコードに含めない
- 本番環境の設定ファイルは共有しない
- 社外秘のソースコードの取り扱いに注意

copy
🎯 まとめ：20ドルProプランの価値
✅ おすすめする人
個人開発者: 月3,000円で十分な機能

学習目的: プログラミング学習の強力な相棒

小規模プロジェクト: スタートアップや趣味開発

Cursor併用: メインツールとの使い分け

✅ 期待できる効果
開発効率40%向上: 実測値

学習速度3倍: 質問しながら実装

コード品質向上: 自動レビュー・改善提案

作業時間短縮: 単純作業の自動化

💡 始め方の推奨ステップ
1ヶ月お試し: まずは月契約で体験

小さなプロジェクト: to-doアプリなどから開始

効率化を学習: /clear やトークン節約テクニック習得

本格活用: 実際のプロジェクトで活用開始

月額3,000円で得られる価値を考えると、Proプランは非常にコストパフォーマンスが高い投資です！

今すぐ始めて、AI開発の新時代を体験しましょう！ 🚀

contains-studio/agents: sharing current agents in use
sharing current agents in use. Contribute to contains-studio/agents development by creating an account on GitHub.

GitHub
今話題のClaude Codeの組織を作ってコーディングするやり方のエージェントをまとめたページです。

Git cloneコマンドの知識が必要です。

わからない人にも丁寧な解説を入れました。
以下Gitの使い方です。わかっている人は飛ばして下さい。

Git初心者完全ガイド - ゼロから始めるGit入門
🤔 Gitって何？
Git（ギット） は、「ファイルの変更履歴を記録・管理するツール」 です。

身近な例で理解しよう
文書作成で考えてみると：

レポート.docx
レポート_修正版.docx
レポート_最終版.docx
レポート_最終版_本当に最終.docx
レポート_提出用.docx

copy
こんな経験ありませんか？Gitは、この 「バージョン管理の悩み」 を解決してくれます。

Gitがあると何ができる？
✅ 変更履歴の保存: いつ、誰が、何を変更したか記録
✅ 元に戻す: 間違えても以前の状態に簡単復旧
✅ 並行作業: 複数人で同じファイルを安全に編集
✅ バックアップ: クラウド上にコードを保存

🚀 Gitのインストール
Windows の場合
方法1: Git for Windows（推奨）

# 1. 以下のサイトからダウンロード
https://git-scm.com/download/win

# 2. ダウンロードしたファイルを実行
# 3. 基本的にデフォルト設定のまま「次へ」を連続クリック

# 4. インストール完認
# コマンドプロンプトまたはPowerShellで確認
git --version

copy
方法2: Winget（Windows 10/11）

# PowerShellを管理者権限で実行
winget install --id Git.Git -e --source winget

copy
macOS の場合
方法1: Homebrew（推奨）

# 1. Homebrewのインストール（未インストールの場合）
/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

# 2. Gitのインストール
brew install git

# 3. 確認
git --version

copy
方法2: Xcode Command Line Tools

# ターミナルで実行
xcode-select --install

copy
Linux (Ubuntu/Debian) の場合
# パッケージリストを更新
sudo apt update

# Gitをインストール
sudo apt install git

# 確認
git --version

copy
インストール確認
全OS共通で以下のコマンドが動けばOK：

git --version
# git version 2.45.0 (または他のバージョン)

copy
⚙️ 初期設定（必須）
Gitを使い始める前に、あなたの情報を登録する必要があります。

基本設定
# あなたの名前を設定（本名推奨）
git config --global user.name "山田太郎"

# あなたのメールアドレスを設定
git config --global user.email "taro.yamada@example.com"

# 設定確認
git config --list

copy
おすすめ追加設定
# デフォルトブランチ名を設定（最近のベストプラクティス）
git config --global init.defaultBranch main

# 改行コードの自動変換設定
# Windows の場合
git config --global core.autocrlf true

# macOS/Linux の場合
git config --global core.autocrlf input

# カラー表示を有効化
git config --global color.ui auto

copy
📚 基本概念の理解
重要な3つのエリア
📁 作業ディレクトリ     📦 ステージングエリア     🗃️ リポジトリ
（普通のフォルダ）      （変更を準備する場所）      （変更履歴の保管庫）
      ↓                      ↓                      ↓
   ファイル編集           git add コマンド        git commit コマンド

copy
用語説明（覚えなくてもOK、参考程度に）
用語 意味 覚え方 リポジトリ プロジェクトの保管庫 図書館のような場所 コミット 変更の記録・保存 スナップショットを撮る ブランチ 並行作業用の枝分かれ 道の分岐点 マージ ブランチを合流させる 分かれた道が合流 クローン リモートをローカルにコピー コピー機でコピー

🛠️ よく使うコマンド
1. プロジェクトを始める
新しいプロジェクトの場合

# 1. プロジェクトフォルダを作成
mkdir my-project
cd my-project

# 2. Gitを初期化
git init

# 完了！「.git」フォルダが作成される

copy
既存のプロジェクトをダウンロードする場合

# GitHubなどからプロジェクトをコピー
git clone https://github.com/ユーザー名/プロジェクト名.git

# フォルダに移動
cd プロジェクト名

copy
2. 変更を記録する基本フロー
# 現在の状況確認
git status

# ファイルをステージングエリアに追加
git add ファイル名.txt

# 全ファイルを追加する場合
git add .

# 変更をコミット（記録）
git commit -m "何を変更したかの説明"

# 例：
git commit -m "ホームページのタイトルを修正"

copy
3. 履歴を見る
# コミット履歴を表示
git log

# 簡潔な履歴表示
git log --oneline

# 最近5件のみ表示
git log --oneline -5

copy
4. 変更内容を確認
# まだコミットしていない変更を確認
git diff

# 特定ファイルの変更確認
git diff ファイル名.txt

# ステージングエリアの変更確認
git diff --staged

copy
🌐 GitHub連携（クラウド保存）
GitHubアカウントの作成
# 1. https://github.com にアクセス
# 2. 「Sign up」でアカウント作成
# 3. メール認証を完了

copy
リモートリポジトリの設定
# GitHub上でリポジトリを作成後

# 1. リモートを追加
git remote add origin https://github.com/あなたのユーザー名/プロジェクト名.git

# 2. 初回アップロード
git push -u origin main

# 3. 以降は简单に
git push

copy
他の人の変更を取得
# 最新の変更をダウンロード
git pull

copy
🎯 実際の作業例
シナリオ：簡単なWebページを作成
# 1. プロジェクト作成
mkdir my-website
cd my-website
git init

# 2. HTMLファイル作成
echo "<h1>私のWebサイト</h1>" > index.html

# 3. 状況確認
git status
# 結果: index.html が「Untracked files」に表示

# 4. ファイルを追加
git add index.html

# 5. 状況再確認
git status
# 結果: index.html が「Changes to be committed」に表示

# 6. コミット
git commit -m "初回：HTMLファイル作成"

# 7. ファイル編集
echo "<p>ようこそ私のサイトへ</p>" >> index.html

# 8. 変更を確認
git diff

# 9. 変更をコミット
git add index.html
git commit -m "ウェルカムメッセージを追加"

# 10. 履歴確認
git log --oneline

copy
🔄 ブランチの基本
ブランチとは？
ブランチ = 並行作業用の作業スペース

main ブランチ:     A --- B --- C --- F
                              ↗     ↗
feature ブランチ:              D --- E

copy
ブランチの操作
# 現在のブランチ確認
git branch

# 新しいブランチ作成
git branch feature-login

# ブランチを切り替え
git checkout feature-login

# 作成と切り替えを同時に
git checkout -b feature-contact

# ブランチをメインに合流（マージ）
git checkout main
git merge feature-login

# ブランチ削除
git branch -d feature-login

copy
🚨 よくあるトラブルと解決法
1. コミットメッセージを間違えた
# 直前のコミットメッセージを修正
git commit --amend -m "正しいメッセージ"

copy
2. ファイルを間違えてコミットした
# 直前のコミットを取り消し（変更は残る）
git reset --soft HEAD~1

# ファイルの変更も含めて完全に取り消し
git reset --hard HEAD~1

copy
3. 変更を元に戻したい
# 特定ファイルの変更を取り消し
git checkout -- ファイル名.txt

# 全ての変更を取り消し（注意：変更内容が失われる）
git checkout -- .

copy
4. マージで競合（コンフリクト）が発生
# 1. 競合箇所を手動で修正
# ファイル内の <<<< ==== >>>> を削除して統合

# 2. 修正後に追加
git add 修正したファイル

# 3. マージ完了
git commit

copy
🎨 便利なGUIツール
初心者におすすめのGUIツール
1. GitHub Desktop（無料・初心者向け）

# ダウンロード先
https://desktop.github.com/

copy
2. Sourcetree（無料・中級者向け）

# ダウンロード先
https://www.sourcetreeapp.com/

copy
3. VS Code内蔵Git機能

# VS Codeがあれば追加インストール不要
# サイドバーのブランチアイコンをクリック

copy
📋 チートシート
毎日使うコマンド
# 状況確認
git status

# 変更を追加
git add .

# 変更をコミット
git commit -m "メッセージ"

# リモートから最新取得
git pull

# リモートに送信
git push

# 履歴確認
git log --oneline

copy
緊急時のコマンド
# 全ての変更を破棄して元に戻す
git reset --hard HEAD

# 直前のコミットを取り消し
git reset --soft HEAD~1

# 特定ファイルを前の状態に戻す
git checkout HEAD -- ファイル名

copy
🔗 学習リソース
公式・信頼できるサイト
Pro Git（無料電子書籍）

GitHub公式ガイド

Atlassian Git チュートリアル

実践練習サイト
Learn Git Branching

GitHub Skills

💡 上達のコツ
1. 毎日少しずつ使う
# 小さなプロジェクトでも毎日コミット
echo "今日の学習メモ" >> diary.txt
git add diary.txt
git commit -m "$(date): 今日の学習記録"

copy
2. 失敗を恐れない
# テスト用フォルダで練習
mkdir git-practice
cd git-practice
git init
# いろいろ試してみる

copy
3. コミットメッセージを丁寧に
❌ 悪い例: git commit -m "修正"
✅ 良い例: git commit -m "ログイン機能のバリデーション追加"

copy
🎉 最初の一歩
今すぐ始めましょう！

# 1. 練習用フォルダ作成
mkdir git-first-try
cd git-first-try

# 2. Git初期化
git init

# 3. 最初のファイル作成
echo "Gitの練習開始！" > README.txt

# 4. 最初のコミット
git add README.txt
git commit -m "初めてのコミット"

# 5. 成功！
git log --oneline

copy
おめでとうございます！あなたの最初のGitリポジトリが完成しました！

Gitは最初は難しく感じますが、毎日少しずつ使っていれば必ず慣れます。焦らず、楽しみながら学習していきましょう！ 🚀

gitの話はここまで。

contains-studio/agents: sharing current agents in use
sharing current agents in use. Contribute to contains-studio/agents development by creating an account on GitHub.

GitHub
今話題のClaude Codeの組織を作ってコーディングするやり方のエージェントをまとめたページです。

忘れないdevなどのフォルダを作って、git cloneしましょう。

git clone https://github.com/contains-studio/agents.git

copy
フォルダを作っておかないとエラーになるので、フォルダを作ります。

mkdir -p ~/.claude/agents

copy
git clone した直後に、移動とかせずに、下記コマンドを打ってください。

cp -r agents/* ~/.claude/agents/

copy
Claudeを再読み込みして下さい。

Claude Codeの実行

claude

copy
 /agentsでAi Engineerなどが選べるようになります。

/agents

copy


画像
Claude Code Sub-Agents 個別呼び出し完全ガイド
📁 contains-studio/agents とは？
contains-studio/agents は、Claude Code のサブエージェント機能を使った専門的な AI エージェントのコレクションです。各エージェントは特定の分野の専門家として設計されており、rapid development の全ての側面を加速・強化することを目的としています。

🚀 セットアップ手順
上でやったことと同じです。
わかりやすくもう一度書いています。

1. リポジトリのクローン
git clone https://github.com/contains-studio/agents.git

copy
2. エージェントファイルのコピー
一括インストール（推奨）

# 全エージェントをコピー
cp -r agents/* ~/.claude/agents/

# または手動でディレクトリ作成してコピー
mkdir -p ~/.claude/agents/
cp -r agents/* ~/.claude/agents/

copy
個別インストール

# 特定のエージェントのみをコピー
cp agents/engineering/rapid-prototyper.md ~/.claude/agents/
cp agents/design/ui-designer.md ~/.claude/agents/
cp agents/marketing/growth-hacker.md ~/.claude/agents/

copy
3. Claude Code の再起動
# Claude Code を再起動してエージェントを読み込み
# ターミナルで Claude Code を終了後、再度起動
claude

copy
🎯 エージェントの個別呼び出し方法
方法1: 明示的な名前指定（最も確実）
# 具体的なエージェント名を指定
"@rapid-prototyper を使って、瞑想習慣トラッキングアプリを作成して"
"@ui-designer でこのボタンをもっと目立つデザインにして"
"@growth-hacker でバイラル戦略を提案して"

copy
方法2: エージェント名の直接言及
# エージェント名を文中で言及
"rapid-prototyper に新しいアプリのプロトタイプを作ってもらいたい"
"ui-designer でダッシュボードのUIを改善して"
"trend-researcher でTikTokでトレンドを調査して"

copy
方法3: 専門分野での自動トリガー
# 特定のタスクでエージェントが自動的に呼び出される
"瞑想習慣を追跡する新しいアプリを作って" → rapid-prototyper が自動起動
"TikTokで何がトレンドか調べて" → trend-researcher が自動起動
"アプリのレビューが下がっている、何が問題？" → feedback-synthesizer が自動起動

copy
📂 利用可能なエージェント一覧
🔧 Engineering（開発系）
@ai-engineer           # AI/ML機能の実装
@backend-architect     # スケーラブルなAPI設計
@devops-automator      # 継続的デプロイメント
@frontend-developer    # 高速UIインターフェース構築
@mobile-app-builder    # ネイティブiOS/Android開発
@rapid-prototyper      # MVP/プロトタイプ構築
@test-writer-fixer     # テスト作成・バグ修正

copy
🎨 Design（デザイン系）
@brand-guardian        # ブランドアイデンティティ管理
@ui-designer          # インターフェースデザイン
@ux-researcher        # ユーザー体験調査
@visual-storyteller   # ビジュアルコンテンツ作成
@whimsy-injector      # 楽しさ・面白さの追加

copy
📢 Marketing（マーケティング系）
@app-store-optimizer   # アプリストア最適化
@content-creator      # コンテンツ作成
@growth-hacker        # グロースハック戦略
@instagram-curator    # Instagram戦略
@reddit-community-builder # Reddit コミュニティ構築
@tiktok-strategist    # TikTok戦略
@twitter-engager      # Twitter エンゲージメント

copy
📊 Product（プロダクト系）
@feedback-synthesizer  # フィードバック分析
@sprint-prioritizer   # スプリント優先順位付け
@trend-researcher     # トレンド調査

copy
🔍 Testing（テスト系）
@api-tester           # API テスト
@performance-benchmarker # パフォーマンス測定
@test-results-analyzer # テスト結果分析
@tool-evaluator       # ツール評価
@workflow-optimizer   # ワークフロー最適化

copy
💡 実践的な使用例
プロトタイプ作成
# 明示的呼び出し
"@rapid-prototyper を使って、AIを活用した読書記録アプリのMVPを作成して。
主要機能：書籍検索、読書進捗管理、AI推薦システム"

copy
UIデザイン改善
# 自動トリガー + 明示的指定
"このログイン画面をもっとモダンで使いやすくしたい。
@ui-designer でダークモード対応も含めて改善して"

copy
マーケティング戦略
# 複数エージェントの連携
"新しいフィットネスアプリのローンチ戦略を立てたい。
@trend-researcher で現在のフィットネストレンドを調査して、
その後 @growth-hacker でバイラル戦略を提案して"

copy
バグ修正とテスト
# 段階的なタスク
"@test-writer-fixer でこのAPIのバグを修正して、
その後 @api-tester で徹底的にテストして"

copy
🛠️ エージェント管理コマンド
利用可能エージェントの確認
claude
/agents

copy
このコマンドで以下が可能：

利用可能な全エージェントの表示

新しいエージェントの作成

既存エージェントの編集・削除

ツールアクセス権限の管理

特定エージェントの詳細確認
# エージェントファイルの内容確認
cat ~/.claude/agents/rapid-prototyper.md
cat ~/.claude/agents/design/ui-designer.md

copy
📝 カスタムエージェント作成
基本的なエージェントファイル構造
---
name: your-custom-agent
description: このエージェントを使用するタイミング。例：「新機能のプロトタイプが必要な時」「UIデザインの改善が必要な時」
color: blue
tools: Write, Read, MultiEdit, Bash
---

あなたは [役割] として [主要機能] を担当します。

あなたの主な責任：
1. [責任1]
2. [責任2]
3. [責任3]

6日スプリントにおいて、あなたは [アプローチ] で作業します。

[詳細なシステムプロンプト...]

copy
カスタムエージェント作成例
---
name: api-documentation-writer
description: APIドキュメント作成が必要な時。例：「新しいAPIエンドポイントの仕様書を作成」「既存APIドキュメントの更新」
color: green
tools: Write, Read, MultiEdit
---

あなたはAPI仕様書作成の専門家です。開発者が理解しやすく、実装に必要な全ての情報を含む包括的なドキュメントを作成します。

主な責任：
1. API エンドポイントの詳細仕様作成
2. サンプルリクエスト・レスポンスの提供
3. エラーコードとハンドリング方法の説明
4. 認証・認可方法の詳細
5. SDKやサンプルコードの提供

6日スプリントで迅速にリリースするため、実装と同時進行でドキュメントを作成し、開発者の作業を妨げないよう効率的に作業します。

copy
🔧 トラブルシューティング
エージェントが認識されない場合
# 1. ファイルパスの確認
ls -la ~/.claude/agents/

# 2. ファイル形式の確認（.md拡張子必須）
file ~/.claude/agents/*.md

# 3. YAML フロントマターの確認
head -10 ~/.claude/agents/rapid-prototyper.md

# 4. Claude Code 再起動
# ターミナルでClaude Codeを終了後、再起動

copy
エージェントの優先順位
プロジェクトレベルとユーザーレベルでエージェント名が競合する場合、プロジェクトレベルのエージェントが優先されます：

# 優先順位（高→低）
.claude/agents/        # プロジェクトレベル（最優先）
~/.claude/agents/      # ユーザーレベル

copy
ツールアクセス権限の設定
# /agents コマンドで視覚的に管理（推奨）
claude
/agents

# または手動でファイル編集
# tools フィールドを編集
tools: Write, Read, Bash  # 特定ツールのみ
# tools フィールド削除   # 全ツール継承（デフォルト）

copy
🎯 効果的な活用のコツ
1. 明確なタスク指定
❌ 悪い例：「アプリを作って」
✅ 良い例：「@rapid-prototyper で読書習慣トラッキングアプリのMVPを作成。機能：本の検索、進捗管理、統計表示」

copy
2. エージェントの組み合わせ
# 段階的なワークフロー
"@trend-researcher でフィットネスアプリのトレンドを調査
→ @rapid-prototyper でプロトタイプ作成
→ @ui-designer でUI改善
→ @growth-hacker でマーケティング戦略立案"

copy
3. プロジェクト固有エージェント
# プロジェクト専用エージェント作成
mkdir -p .claude/agents/
cp ~/.claude/agents/rapid-prototyper.md .claude/agents/my-project-prototyper.md
# プロジェクト要件に合わせてカスタマイズ

copy
これで、contains-studio/agents の個別エージェントを効率的に活用できるようになります！6日スプリント哲学に基づいて設計されたこれらのエージェントで、開発速度を劇的に向上させましょう🚀

contains-studio/agents の個別エージェント呼び出し方法について、詳細なガイドを作成しました！

🎯 核心ポイント
3つの呼び出し方法
@エージェント名 - 最も確実な明示的指定

エージェント名の直接言及 - 自然な会話形式

自動トリガー - タスク内容に基づく自動選択

セットアップは簡単3ステップ
リポジトリクローン

~/.claude/agents/ にコピー

Claude Code 再起動

豊富なエージェント群
Engineering系: @rapid-prototyper, @frontend-developerなど

Design系: @ui-designer, @whimsy-injectorなど

Marketing系: @growth-hacker, @tiktok-strategistなど

Product系: @trend-researcher, @feedback-synthesizerなど

実践例
# 明示的呼び出し
"@rapid-prototyper で瞑想アプリのMVPを作成して"

# 複数エージェント連携
"@trend-researcher でトレンド調査 → @ui-designer でUI設計"

# 自動トリガー
"TikTokで何がトレンド？" → tiktok-strategist が自動起動

copy
管理機能
/agents コマンドで全エージェント管理

カスタムエージェント作成可能

プロジェクト固有設定サポート

6日スプリント哲学に基づいて設計されたこれらのエージェントで、開発効率を劇的に向上させることができます。特に@rapid-prototyperと@ui-designerの組み合わせは、アイデアから実装まで驚異的なスピードを実現します！

@rapid-prototyper × @ui-designer 連携実践例
🚀 なぜこの組み合わせが最強なのか？
@rapid-prototyper は機能を作る専門家、@ui-designer は見た目を美しくする専門家です。この2つのエージェントが連携することで、**「動くものを作る → 美しく仕上げる」**という理想的な開発フローが実現できます。

典型的なワークフロー
アイデア → @rapid-prototyper → 動くプロトタイプ → @ui-designer → 美しいUI → 完成品

copy
💡 具体的な実践例
例1: 瞑想習慣トラッキングアプリ
フェーズ1: @rapid-prototyper でのプロトタイプ作成

ユーザーの指示:

"@rapid-prototyper を使って、瞑想習慣を追跡するアプリのMVPを作成してください。
主要機能：
- 瞑想セッションのタイマー
- 日別の記録
- 週間・月間の統計表示
- 簡単な設定画面"

copy
@rapid-prototyper の作業内容:

プロジェクト構造の作成

meditation-tracker/
├── src/
│   ├── components/
│   │   ├── Timer.jsx
│   │   ├── SessionList.jsx
│   │   ├── Statistics.jsx
│   │   └── Settings.jsx
│   ├── hooks/
│   │   └── useLocalStorage.js
│   ├── utils/
│   │   └── timeUtils.js
│   └── App.jsx
├── package.json
└── README.md

copy
核心機能の実装

// Timer.jsx - 基本的なタイマー機能
const Timer = () => {
  const [seconds, setSeconds] = useState(0);
  const [isActive, setIsActive] = useState(false);
  
  // 基本的なタイマーロジック
  useEffect(() => {
    let interval = null;
    if (isActive) {
      interval = setInterval(() => {
        setSeconds(seconds => seconds + 1);
      }, 1000);
    }
    return () => clearInterval(interval);
  }, [isActive, seconds]);

  return (
    <div className="timer">
      <div className="time-display">{formatTime(seconds)}</div>
      <button onClick={() => setIsActive(!isActive)}>
        {isActive ? 'Pause' : 'Start'}
      </button>
    </div>
  );
};

copy
データ管理の実装

// useLocalStorage.js - データ永続化
export const useLocalStorage = (key, initialValue) => {
  const [value, setValue] = useState(() => {
    const item = window.localStorage.getItem(key);
    return item ? JSON.parse(item) : initialValue;
  });

  const setStoredValue = (value) => {
    setValue(value);
    window.localStorage.setItem(key, JSON.stringify(value));
  };

  return [value, setStoredValue];
};

copy
結果: 5-10分で動作する基本的なアプリが完成

フェーズ2: @ui-designer での美しいUI作成

ユーザーの指示:

"@ui-designer で、この瞑想アプリのUIを美しく、直感的で、心地よいデザインに改善してください。
瞑想アプリらしい落ち着いた雰囲気で、ユーザーが集中できるような配色とレイアウトにしてください。"

copy
@ui-designer の作業内容:

デザインシステムの確立

// designTokens.js
export const theme = {
  colors: {
    primary: {
      50: '#f0f9ff',   // 非常に薄い青
      100: '#e0f2fe',  // 薄い青
      500: '#3b82f6',  // メイン青
      600: '#2563eb',  // 濃い青
      900: '#1e3a8a'   // 非常に濃い青
    },
    neutral: {
      50: '#fafaf9',   // ほぼ白
      100: '#f5f5f4',  // 薄いグレー
      500: '#71717a',  // ミディアムグレー
      700: '#3f3f46',  // 濃いグレー
      900: '#18181b'   // ほぼ黒
    },
    accent: {
      green: '#10b981', // 成功色
      purple: '#8b5cf6', // アクセント色
      orange: '#f59e0b'  // 警告色
    }
  },
  spacing: {
    xs: '0.5rem',    // 8px
    sm: '1rem',      // 16px
    md: '1.5rem',    // 24px
    lg: '2rem',      // 32px
    xl: '3rem',      // 48px
  },
  typography: {
    display: '2.25rem',  // 36px
    h1: '1.875rem',      // 30px
    h2: '1.5rem',        // 24px
    body: '1rem',        // 16px
    small: '0.875rem'    // 14px
  }
};

copy
美しいタイマーコンポーネント

// Timer.jsx - 美しいUI版
const Timer = () => {
  return (
    <div className="timer-container">
      {/* グラデーション背景 */}
      <div className="timer-background">
        <div className="gradient-orb"></div>
      </div>
      
      {/* メインタイマー */}
      <div className="timer-circle">
        <svg className="progress-ring" width="200" height="200">
          <circle
            className="progress-ring-background"
            cx="100" cy="100" r="90"
            fill="transparent"
            stroke="#e5e7eb"
            strokeWidth="8"
          />
          <circle
            className="progress-ring-progress"
            cx="100" cy="100" r="90"
            fill="transparent"
            stroke="#3b82f6"
            strokeWidth="8"
            strokeDasharray={`${circumference} ${circumference}`}
            strokeDashoffset={offset}
            transform="rotate(-90 100 100)"
          />
        </svg>
        
        <div className="timer-content">
          <div className="time-display">{formatTime(seconds)}</div>
          <div className="session-type">瞑想セッション</div>
        </div>
      </div>
      
      {/* 美しいボタン */}
      <div className="timer-controls">
        <button 
          className={`timer-button ${isActive ? 'pause' : 'start'}`}
          onClick={() => setIsActive(!isActive)}
        >
          {isActive ? (
            <>
              <PauseIcon />
              一時停止
            </>
          ) : (
            <>
              <PlayIcon />
              開始
            </>
          )}
        </button>
      </div>
    </div>
  );
};

copy
統計画面の美しいデザイン

// Statistics.jsx - 美しい統計表示
const Statistics = ({ sessions }) => {
  return (
    <div className="statistics-container">
      <h2 className="stats-title">あなたの瞑想記録</h2>
      
      {/* サマリーカード */}
      <div className="stats-grid">
        <StatCard
          icon={<ClockIcon />}
          title="今週の合計時間"
          value="2時間 30分"
          trend="+15%"
          color="blue"
        />
        <StatCard
          icon={<CalendarIcon />}
          title="連続記録"
          value="7日"
          trend="New Record!"
          color="green"
        />
        <StatCard
          icon={<TrendingUpIcon />}
          title="月間セッション"
          value="24回"
          trend="+8%"
          color="purple"
        />
      </div>
      
      {/* 美しいチャート */}
      <div className="chart-container">
        <h3>週間の瞑想時間</h3>
        <WeeklyChart data={weeklyData} />
      </div>
      
      {/* セッション履歴 */}
      <div className="session-history">
        <h3>最近のセッション</h3>
        {sessions.map(session => (
          <SessionCard 
            key={session.id}
            session={session}
          />
        ))}
      </div>
    </div>
  );
};

copy
レスポンシブ & アクセシブルなCSS

/* Timer.css - 美しいスタイル */
.timer-container {
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  position: relative;
  overflow: hidden;
}

.timer-background {
  position: absolute;
  inset: 0;
  opacity: 0.1;
}

.gradient-orb {
  width: 400px;
  height: 400px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(59, 130, 246, 0.6) 0%, transparent 70%);
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  animation: pulse 4s ease-in-out infinite;
}

.timer-circle {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.timer-content {
  position: absolute;
  text-align: center;
  color: white;
}

.time-display {
  font-size: 2.5rem;
  font-weight: 300;
  letter-spacing: 0.05em;
  margin-bottom: 0.5rem;
}

.session-type {
  font-size: 0.875rem;
  opacity: 0.8;
  text-transform: uppercase;
  letter-spacing: 0.1em;
}

.timer-button {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 1rem 2rem;
  border: none;
  border-radius: 50px;
  background: rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(10px);
  color: white;
  font-size: 1.125rem;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  margin-top: 2rem;
}

.timer-button:hover {
  background: rgba(255, 255, 255, 0.3);
  transform: translateY(-2px);
  box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
}

/* レスポンシブデザイン */
@media (max-width: 768px) {
  .timer-circle svg {
    width: 160px;
    height: 160px;
  }
  
  .time-display {
    font-size: 2rem;
  }
  
  .timer-button {
    padding: 0.875rem 1.5rem;
    font-size: 1rem;
  }
}

@keyframes pulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); }
  50% { transform: translate(-50%, -50%) scale(1.1); }
}

copy
結果: 心地よく美しい瞑想アプリの完成！

例2: TikTokトレンド分析ダッシュボード
フェーズ1: @rapid-prototyper

指示:

"@rapid-prototyper で、TikTokのトレンドを分析するダッシュボードを作成。
機能：トレンド検索、ハッシュタグ分析、動画統計表示"

copy
作業内容:

APIモックデータの作成

検索機能の実装

基本的なチャート表示

データフィルタリング機能

フェーズ2: @ui-designer

指示:

"@ui-designer で、このダッシュボードをTikTokらしいバイブラントで楽しい
デザインに変更。データ可視化を美しく、SNSマーケター向けの
プロフェッショナルな仕上がりに。"

copy
改善内容:

TikTokブランドカラーの採用

インタラクティブなチャート

アニメーション効果

モバイルファーストデザイン

例3: AIアバター生成アプリ
@rapid-prototyper フェーズ

"@rapid-prototyper で、AIアバター生成アプリのプロトタイプを作成。
最新のTikTokトレンドを参考に、バイラル要素を含めて。"

copy
実装内容:

ファイルアップロード機能

AI API統合（OpenAI DALL-E）

スタイル選択機能

生成結果の保存・共有

@ui-designer フェーズ

"@ui-designer で、このアプリをInstagramのようなおしゃれで
直感的なUIに仕上げて。ジェネレーション過程も楽しめるように。"

copy
デザイン改善:

Instagram風の洗練されたレイアウト

生成過程のアニメーション

美しいギャラリー表示

ソーシャル共有機能

🔄 効率的な連携パターン
パターン1: 段階的改善
# ステップ1: 基本機能
"@rapid-prototyper で〇〇アプリの基本機能を実装"

# ステップ2: UI改善
"@ui-designer で見た目を美しく改善"

# ステップ3: 機能追加
"@rapid-prototyper で追加機能〇〇を実装"

# ステップ4: 最終調整
"@ui-designer で全体の統一感を調整"

copy
パターン2: 同時並行作業
# メイン機能の実装
"@rapid-prototyper でメインダッシュボード機能を実装して、
同時に @ui-designer でサイドバーとナビゲーションのUIを作成"

copy
パターン3: 特化型分担
# 役割分担の明確化
"@rapid-prototyper はAPI統合とデータ処理を担当、
@ui-designer はコンポーネントライブラリとデザインシステムを担当"

copy
🎯 成功のためのコツ
1. 明確な役割分担
✅ 良い例：
"@rapid-prototyper で機能実装、@ui-designer で見た目改善"

❌ 悪い例：
"両方のエージェントで全部やって"

copy
2. 段階的なフィードバック
# プロトタイプ完成後
"@rapid-prototyper の作業を確認してから @ui-designer に移行"

# UI改善後
"@ui-designer の改善点を確認してから次の機能へ"

copy
3. 具体的な指示
✅ 具体的：
"@ui-designer で、Netflix風のダークテーマでカード型レイアウト"

❌ 抽象的：
"@ui-designer でかっこよく"

copy
⚡ 実際の会話例
シナリオ: 読書記録アプリの開発
ユーザー: "読書記録アプリを作りたい"

Claude: "@rapid-prototyper を使って、読書記録アプリのMVPを作成しましょう。
        基本機能から始めて、その後 @ui-designer で美しく仕上げます。"

# フェーズ1: プロトタイプ作成
@rapid-prototyper: 
"📚 読書記録アプリのプロトタイプを作成中...
- 本の検索・追加機能
- 読書進捗管理
- 読了本一覧
- 読書統計表示
基本機能が完成しました！動作確認をお願いします。"

ユーザー: "動作確認OK！UIをもっと読書好きにアピールするデザインに"

# フェーズ2: UI改善
@ui-designer:
"📖 読書アプリらしい温かみのあるデザインに改善中...
- 本棚をイメージしたレイアウト
- 読書進捗の視覚的表示
- 心地よい配色とタイポグラフィ
- ページめくりアニメーション
美しい読書記録アプリが完成しました！"

copy
🚀 効果測定
開発スピードの比較
従来の開発方法:

要件定義: 1日

プロトタイプ作成: 3-5日

UI/UXデザイン: 2-3日

実装・調整: 2-3日

合計: 8-12日

@rapid-prototyper × @ui-designer:

プロトタイプ作成: 10-30分

UI改善: 15-45分

最終調整: 10-20分

合計: 35-95分

品質向上ポイント
一貫性: デザインシステムベースのUI

実用性: 動作するプロトタイプから開始

完成度: プロ仕様の美しいインターフェース

保守性: クリーンなコード構造

💡 応用アイデア
1. 業界別テンプレート作成
# SaaS ダッシュボード
"@rapid-prototyper でSaaS管理画面の基盤を作成 
→ @ui-designer でエンタープライズ向けの洗練されたデザイン"

# Eコマースサイト
"@rapid-prototyper でECサイトの基本機能を実装
→ @ui-designer でコンバージョン重視の魅力的なデザイン"

# 教育アプリ
"@rapid-prototyper で学習管理システムを構築
→ @ui-designer で子供向けの楽しく学べるインターフェース"

copy
2. プラットフォーム特化開発
# モバイルファースト
"@rapid-prototyper でPWA対応アプリを作成
→ @ui-designer でネイティブアプリ風のUX"

# デスクトップアプリ
"@rapid-prototyper でElectronアプリの基盤
→ @ui-designer でOS別の最適化されたデザイン"

copy
3. バイラル要素の組み込み
# ソーシャル機能
"@rapid-prototyper でソーシャル共有機能を実装
→ @ui-designer でInstagram風のシェア体験"

# ゲーミフィケーション
"@rapid-prototyper でポイント・レベルシステム
→ @ui-designer でゲーム風の楽しいUI"

copy
🎯 まとめ: 最強の組み合わせを活用しよう
@rapid-prototyper × @ui-designer の組み合わせは、現代の高速開発において最も効果的なワークフローです：

✅ 導入すべき理由
開発時間を90%以上短縮

プロ品質のアウトプット

アイデアから完成まで1時間以内

継続的な改善が容易

🚀 今すぐ試すべきプロジェクト
個人的なツールアプリ

社内用の管理ダッシュボード

新規事業のMVP

既存サービスの機能追加

6日スプリント哲学に基づき、完璧を求めず「動くものを作って改善する」このアプローチで、あなたの開発効率は劇的に向上します！

@rapid-prototyper × @ui-designer の組み合わせについて、詳細な実践ガイドを作成しました！

🎯 核心ポイント
驚異的な開発スピード
従来: 8-12日 → AI連携: 35-95分

90%以上の時間短縮を実現

完璧なワークフロー
@rapid-prototyper → 動作する基本機能

@ui-designer → 美しく洗練されたUI

段階的改善 → プロ品質の完成品

具体例で見る威力
瞑想アプリの場合:

10分で基本タイマー機能完成

15分で美しいUI（グラデーション、アニメーション）

5分で統計画面とカード型レイアウト

合計30分でプロ品質のアプリ完成！

実際のコード例
デザインシステム構築

美しいタイマーコンポーネント

インタラクティブな統計表示

レスポンシブ & アクセシブル対応

3つの効率的パターン
段階的改善: 機能→UI→追加機能→最終調整

同時並行作業: メイン機能とUI並行開発

特化型分担: 明確な役割分担

**「アイデアから完成まで1時間以内」**という革命的な開発体験で、あなたの創造性を最大限に発揮できます。6日スプリント哲学の真髄がここにあります！🚀

全最新の全自動コーディングの全て
ここから先は、私が実際に作った方法をまとめます。

# 1. ディレクトリ作成
mkdir -p ~/.claude/commands

copy


# 2. コマンドファイルを設置
cat > ~/.claude/commands/ticket-split.md << 'EOF'
# チケット分割タスク

要件定義書または機能仕様を機能毎にチケットに分割し、以下の形式で管理してください：

## 対象ファイル
$ARGUMENTS

## 実行手順
1. **分割作業**: 要件や機能を元に、機能毎に独立したチケットを作成
2. **ファイル配置**: `/docs`配下にマークダウンファイルとして保存
3. **命名規則**: ファイル名の先頭に連番を付ける（例：`001_ユーザー認証.md`, `002_データ管理.md`）
4. **Todo管理**: 各ファイル内でタスクの進捗管理を行う
   - 未完了: `- [ ] タスク名`
   - 完了: `- [x] タスク名`
5. **ルール記載**: `CLAUDE.md`ファイルに上記のルールを記載

## 出力形式
各チケットには以下を含める：
- **機能概要**: 機能の目的と概要説明
- **詳細要件**: 具体的な実装要件
- **Todoリスト**: 実装すべきタスクの一覧
- **依存関係**: 他の機能との依存関係
- **受け入れ基準**: 完了判定の基準

実装完了時はTodoの状態を`- [x]`に更新し、CLAUDE.mdファイルにも進捗を記録してください。
EOF

copy
# 3. 権限設定
chmod 644 ~/.claude/commands/ticket-split.md

copy
# 4. 確認
ls -la ~/.claude/commands/

copy
Web版のClaudeにした要件。自分が作りたいものに適宜置き換えて下さい。
あくまでも、サンプルです。

VMDファイルの動きの制御やリップシンク出来るスマホでXのaniちゃんみたいな画面をexpo react nativeで作りたいです。仕様書を[]でタスクごとに分けて開発するようなタスクをClaude codenのCLAUDE.mdに貼り付けることを前提で001番から順番に実装するのに必要な項目を書き出してください。
終わっていないタスクは　 [] で終わったらチェックをつけれるようにしてください。

copy
共通部分はこれです。

仕様書を[]でタスクごとに分けて開発するようなタスクをClaude codenのCLAUDE.md
に貼り付けることを前提で001番から順番に実装するのに必要な項目を書き出してください。
終わっていないタスクは　 [] で終わったらチェックをつけれるようにしてください。

copy
Claudeから出力された例です。

# VMDアニメーションアプリ開発タスクリスト（Claude Code用）

## 概要
Expo React Nativeを使用して、VMDファイルの3Dキャラクターアニメーションとリップシンク機能を持つスマホアプリを開発する。

---

## 開発タスク一覧

### [001] プロジェクト初期セットアップ
- [ ] Expo CLIでプロジェクト作成
- [ ] 必要な依存関係のインストール（expo-gl, expo-gl-cpp, expo-three等）
- [ ] TypeScript設定ファイル作成
- [ ] 基本的なフォルダ構造作成（components, screens, utils, types, assets）
- [ ] Git初期化とリポジトリ設定
- [ ] 基本的なExpoアプリの動作確認

**成果物**: 動作する基本的なExpoアプリ

---

### [002] 3Dレンダリング環境構築
- [ ] expo-gl と Three.js の統合設定
- [ ] 基本的な3Dシーン作成（カメラ、ライト、レンダラー）
- [ ] 3D表示用のコンポーネント作成
- [ ] タッチジェスチャーでのカメラ操作実装（回転、ズーム）
- [ ] 基本的な3Dオブジェクト（キューブ等）の表示テスト
- [ ] レンダリングループの最適化

**成果物**: 3D空間にオブジェクトを表示し、タッチで操作できる画面

---

### [003] MMDモデル読み込み機能
- [ ] PMXファイルフォーマットの解析ライブラリ作成/統合
- [ ] 3Dモデルの頂点データ読み込み処理
- [ ] テクスチャファイルの読み込みと適用
- [ ] ボーン情報の抽出と構造化
- [ ] Three.jsでのMMDモデル表示実装
- [ ] モデルファイルの非同期読み込み処理
- [ ] エラーハンドリング（ファイル形式不正、読み込み失敗等）

**成果物**: PMXファイルから3Dキャラクターモデルを読み込み表示

---

### [004] VMDファイル解析機能
- [ ] VMDファイルフォーマットの解析機能実装
- [ ] ボーンモーションデータの抽出
- [ ] 表情モーションデータの抽出
- [ ] カメラモーションデータの抽出
- [ ] モーションデータの構造化（TypeScript型定義）
- [ ] 補間曲線の処理実装
- [ ] VMDファイルの検証機能

**成果物**: VMDファイルからモーションデータを抽出するライブラリ

---

### [005] 基本アニメーション再生機能
- [ ] ボーンアニメーションの実装
- [ ] フレーム間の補間処理（線形補間）
- [ ] ベジェ曲線補間の実装
- [ ] アニメーション再生コントロール（再生/停止/一時停止）
- [ ] 再生速度調整機能
- [ ] ループ再生機能
- [ ] タイムライン表示機能

**成果物**: VMDモーションを再生できる基本的なアニメーションシステム

---

### [006] 表情モーフィング機能
- [ ] 表情モーフの頂点変形処理
- [ ] 表情キーフレームの補間
- [ ] 複数表情の合成処理
- [ ] 表情アニメーションの再生制御
- [ ] プリセット表情の作成（笑顔、困り顔等）
- [ ] 表情の強度調整機能

**成果物**: キャラクターの表情を動的に変更できる機能

---

### [007] リップシンク基礎機能
- [ ] 音声ファイルの読み込み（WAV, MP3対応）
- [ ] 音声の周波数解析（FFT）実装
- [ ] 音量レベルの取得
- [ ] 基本的な母音判定アルゴリズム
- [ ] 音声再生との同期機能
- [ ] リアルタイム音声解析

**成果物**: 音声に連動する基本的な口の動き

---

### [008] 高精度リップシンク機能
- [ ] 音韻解析の精度向上
- [ ] あいうえお対応の口形状定義
- [ ] 音声波形からの子音検出
- [ ] 口形状の滑らかな遷移実装
- [ ] 日本語特化のリップシンクアルゴリズム
- [ ] リップシンクの遅延調整機能

**成果物**: 自然な日本語リップシンク機能

---

### [009] ユーザーインターフェース構築
- [ ] メイン画面のレイアウト設計
- [ ] アニメーション制御パネル作成
- [ ] ファイル選択インターフェース
- [ ] 設定画面（音量、画質等）
- [ ] アニメーションタイムライン表示
- [ ] ボタンのタッチフィードバック実装

**成果物**: 直感的な操作が可能なUI

---

### [010] ファイル管理システム
- [ ] ファイルブラウザ機能
- [ ] ファイルのインポート機能
- [ ] ファイルのエクスポート機能
- [ ] ファイルの組み合わせ保存（プリセット）
- [ ] ファイル形式の検証
- [ ] ファイル容量の最適化

**成果物**: ファイルを効率的に管理できるシステム

---

### [011] カメラ・ライティング制御
- [ ] 自動カメラワーク（VMDカメラモーション対応）
- [ ] 手動カメラ操作の改良
- [ ] 複数ライト設定（環境光、指向性ライト等）
- [ ] 影の表現実装
- [ ] ポストプロセス効果（ブルーム等）
- [ ] カメラアングルのプリセット機能

**成果物**: 美しい3D映像を生成する機能

---

### [012] パフォーマンス最適化
- [ ] レンダリング最適化（LOD、カリング）
- [ ] メモリ使用量の削減
- [ ] フレームレート安定化
- [ ] バッテリー消費の最適化
- [ ] 低スペック端末での動作調整
- [ ] ガベージコレクション対策

**成果物**: 幅広い端末で快適に動作するアプリ

---

### [013] 音声・効果音システム
- [ ] BGM再生機能
- [ ] 効果音の同期再生
- [ ] 音声エフェクト（リバーブ、エコー等）
- [ ] 音量の個別調整
- [ ] 音声ファイルの圧縮・最適化
- [ ] 音声の空間配置（3Dオーディオ）

**成果物**: 没入感の高い音響システム

---

### [014] エクスポート・共有機能
- [ ] 動画ファイル出力（MP4）
- [ ] GIFアニメーション出力
- [ ] 静止画キャプチャ
- [ ] SNS共有機能
- [ ] クラウドストレージ連携
- [ ] 出力品質設定

**成果物**: アニメーションを様々な形式で出力・共有できる機能

---

### [015] 高度なアニメーション機能
- [ ] 物理演算（髪、服の揺れ）
- [ ] パーティクルエフェクト
- [ ] ポストエフェクト（ブラー、色調補正）
- [ ] 複数キャラクターの同時表示
- [ ] インタラクティブなアニメーション
- [ ] IK（Inverse Kinematics）機能

**成果物**: プロレベルのアニメーション表現

---

### [016] ユーザー設定・カスタマイズ
- [ ] 詳細設定画面
- [ ] テーマ・カラー設定
- [ ] ジェスチャー操作のカスタマイズ
- [ ] データのバックアップ機能
- [ ] データの復元機能
- [ ] 多言語対応準備

**成果物**: ユーザーの好みに合わせてカスタマイズ可能なアプリ

---

### [017] エラーハンドリング・デバッグ機能
- [ ] 包括的なエラーハンドリング
- [ ] ログ機能の実装
- [ ] デバッグモードの追加
- [ ] パフォーマンス監視
- [ ] クラッシュレポート機能
- [ ] ユーザーフィードバック機能

**成果物**: 堅牢で保守しやすいアプリケーション

---

### [018] 最終調整・リリース準備
- [ ] 全機能の統合テスト
- [ ] UIのポリッシュ
- [ ] パフォーマンステスト
- [ ] セキュリティ検証
- [ ] アプリストア申請準備
- [ ] プライバシーポリシー作成

**成果物**: リリース可能な完成版アプリ

---

## 開発優先順位
1. **基盤構築** [001]〜[003] - 基本的な3D表示環境
2. **コア機能** [004]〜[006] - VMDアニメーション再生
3. **リップシンク** [007]〜[008] - メイン機能の実装
4. **ユーザー体験** [009]〜[011] - 操作性向上
5. **最適化・拡張** [012]〜[018] - 品質向上とリリース準備

## 技術スタック
- **Frontend**: Expo React Native, TypeScript
- **3D Engine**: Three.js, expo-gl
- **音声処理**: expo-av, Web Audio API
- **ファイル処理**: expo-file-system
- **状態管理**: React Context API or Zustand

## 使用方法
各タスクの完了時は `- [ ]` を `- [x]` に変更してチェックマークをつけてください。
Claude Codeでの開発時は、該当するタスク番号を参照して段階的に実装を進めてください。

copy


/initの後にCLAUDE.mdに貼り付けて下さい。
下記はサンプル

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview
OtoPedia is a React Native mobile application built with Expo for cross-platform deployment (iOS, Android, Web). It uses the latest React Native New Architecture with file-based routing via Expo Router.

## Essential Commands

### Development
```bash
# Start development server (opens Expo Dev Client)
npm start

# Platform-specific development
npm run ios      # Start iOS simulator
npm run android  # Start Android emulator  
npm run web      # Start web browser

# Code quality
npm run lint     # Run ESLint checks

# Reset template (if starting fresh)
npm run reset-project
```

### Testing & Debugging
- Press `j` in terminal to open debugger
- Press `r` to reload app
- Press `m` to toggle menu

## Architecture & Code Structure

### File-based Routing
- Routes defined in `/app` directory using Expo Router
- `(tabs)` group for tab navigation
- `_layout.tsx` files define navigation structure
- Route params accessed via `useLocalSearchParams()`

### Component Architecture
```
components/
├── ui/           # Platform-specific UI components (iOS/Android/Web)
├── Themed*.tsx   # Theme-aware components wrapping native elements
└── *.tsx         # Reusable components
```

### Theme System
- Colors defined in `constants/Colors.ts` for light/dark modes
- Use `useThemeColor()` hook for theme-aware colors
- Wrap text/views with `ThemedText`/`ThemedView` for automatic theming
- Color scheme auto-detected, can be overridden

### TypeScript Configuration
- Strict mode enabled
- Path aliases: `@/` maps to root directory
- Use typed imports for better IntelliSense

## Key Development Patterns

### Creating New Screens
1. Add file to `/app` directory (becomes route automatically)
2. Export default React component
3. Use `Stack.Screen` or tab options for navigation config

### Adding Components
1. Create in `/components` with TypeScript
2. Use themed wrappers for consistent styling
3. Platform-specific code goes in `/components/ui/`

### Working with Assets
- Images: `/assets/images/`
- Fonts: Already configured in `app/_layout.tsx`
- Icons: Use `@expo/vector-icons` or `expo-symbols`

## Platform Considerations
- Use `Platform.select()` for platform-specific values
- Components in `/components/ui/` handle platform differences
- Web-specific styles use `@media` queries or Platform checks

## State Management
Currently using React hooks and context. For complex state, consider adding:
- Redux Toolkit
- Zustand
- MobX

## Important Files
- `app.json`: Expo configuration (app name, version, etc.)
- `tsconfig.json`: TypeScript settings (strict mode)
- `eslint.config.js`: Linting rules

# VMDアニメーションアプリ開発タスクリスト（Claude Code用）

## 概要
Expo React Nativeを使用して、VMDファイルの3Dキャラクターアニメーションとリップシンク機能を持つスマホアプリを開発する。

---

## 開発タスク一覧

### [001] プロジェクト初期セットアップ
- [ ] Expo CLIでプロジェクト作成
- [ ] 必要な依存関係のインストール（expo-gl, expo-gl-cpp, expo-three等）
- [ ] TypeScript設定ファイル作成
- [ ] 基本的なフォルダ構造作成（components, screens, utils, types, assets）
- [ ] Git初期化とリポジトリ設定
- [ ] 基本的なExpoアプリの動作確認

**成果物**: 動作する基本的なExpoアプリ

---

### [002] 3Dレンダリング環境構築
- [ ] expo-gl と Three.js の統合設定
- [ ] 基本的な3Dシーン作成（カメラ、ライト、レンダラー）
- [ ] 3D表示用のコンポーネント作成
- [ ] タッチジェスチャーでのカメラ操作実装（回転、ズーム）
- [ ] 基本的な3Dオブジェクト（キューブ等）の表示テスト
- [ ] レンダリングループの最適化

**成果物**: 3D空間にオブジェクトを表示し、タッチで操作できる画面

---

### [003] MMDモデル読み込み機能
- [ ] PMXファイルフォーマットの解析ライブラリ作成/統合
- [ ] 3Dモデルの頂点データ読み込み処理
- [ ] テクスチャファイルの読み込みと適用
- [ ] ボーン情報の抽出と構造化
- [ ] Three.jsでのMMDモデル表示実装
- [ ] モデルファイルの非同期読み込み処理
- [ ] エラーハンドリング（ファイル形式不正、読み込み失敗等）

**成果物**: PMXファイルから3Dキャラクターモデルを読み込み表示

---

### [004] VMDファイル解析機能
- [ ] VMDファイルフォーマットの解析機能実装
- [ ] ボーンモーションデータの抽出
- [ ] 表情モーションデータの抽出
- [ ] カメラモーションデータの抽出
- [ ] モーションデータの構造化（TypeScript型定義）
- [ ] 補間曲線の処理実装
- [ ] VMDファイルの検証機能

**成果物**: VMDファイルからモーションデータを抽出するライブラリ

---

### [005] 基本アニメーション再生機能
- [ ] ボーンアニメーションの実装
- [ ] フレーム間の補間処理（線形補間）
- [ ] ベジェ曲線補間の実装
- [ ] アニメーション再生コントロール（再生/停止/一時停止）
- [ ] 再生速度調整機能
- [ ] ループ再生機能
- [ ] タイムライン表示機能

**成果物**: VMDモーションを再生できる基本的なアニメーションシステム

---

### [006] 表情モーフィング機能
- [ ] 表情モーフの頂点変形処理
- [ ] 表情キーフレームの補間
- [ ] 複数表情の合成処理
- [ ] 表情アニメーションの再生制御
- [ ] プリセット表情の作成（笑顔、困り顔等）
- [ ] 表情の強度調整機能

**成果物**: キャラクターの表情を動的に変更できる機能

---

### [007] リップシンク基礎機能
- [ ] 音声ファイルの読み込み（WAV, MP3対応）
- [ ] 音声の周波数解析（FFT）実装
- [ ] 音量レベルの取得
- [ ] 基本的な母音判定アルゴリズム
- [ ] 音声再生との同期機能
- [ ] リアルタイム音声解析

**成果物**: 音声に連動する基本的な口の動き

---

### [008] 高精度リップシンク機能
- [ ] 音韻解析の精度向上
- [ ] あいうえお対応の口形状定義
- [ ] 音声波形からの子音検出
- [ ] 口形状の滑らかな遷移実装
- [ ] 日本語特化のリップシンクアルゴリズム
- [ ] リップシンクの遅延調整機能

**成果物**: 自然な日本語リップシンク機能

---

### [009] ユーザーインターフェース構築
- [ ] メイン画面のレイアウト設計
- [ ] アニメーション制御パネル作成
- [ ] ファイル選択インターフェース
- [ ] 設定画面（音量、画質等）
- [ ] アニメーションタイムライン表示
- [ ] ボタンのタッチフィードバック実装

**成果物**: 直感的な操作が可能なUI

---

### [010] ファイル管理システム
- [ ] ファイルブラウザ機能
- [ ] ファイルのインポート機能
- [ ] ファイルのエクスポート機能
- [ ] ファイルの組み合わせ保存（プリセット）
- [ ] ファイル形式の検証
- [ ] ファイル容量の最適化

**成果物**: ファイルを効率的に管理できるシステム

---

### [011] カメラ・ライティング制御
- [ ] 自動カメラワーク（VMDカメラモーション対応）
- [ ] 手動カメラ操作の改良
- [ ] 複数ライト設定（環境光、指向性ライト等）
- [ ] 影の表現実装
- [ ] ポストプロセス効果（ブルーム等）
- [ ] カメラアングルのプリセット機能

**成果物**: 美しい3D映像を生成する機能

---

### [012] パフォーマンス最適化
- [ ] レンダリング最適化（LOD、カリング）
- [ ] メモリ使用量の削減
- [ ] フレームレート安定化
- [ ] バッテリー消費の最適化
- [ ] 低スペック端末での動作調整
- [ ] ガベージコレクション対策

**成果物**: 幅広い端末で快適に動作するアプリ

---

### [013] 音声・効果音システム
- [ ] BGM再生機能
- [ ] 効果音の同期再生
- [ ] 音声エフェクト（リバーブ、エコー等）
- [ ] 音量の個別調整
- [ ] 音声ファイルの圧縮・最適化
- [ ] 音声の空間配置（3Dオーディオ）

**成果物**: 没入感の高い音響システム

---

### [014] エクスポート・共有機能
- [ ] 動画ファイル出力（MP4）
- [ ] GIFアニメーション出力
- [ ] 静止画キャプチャ
- [ ] SNS共有機能
- [ ] クラウドストレージ連携
- [ ] 出力品質設定

**成果物**: アニメーションを様々な形式で出力・共有できる機能

---

### [015] 高度なアニメーション機能
- [ ] 物理演算（髪、服の揺れ）
- [ ] パーティクルエフェクト
- [ ] ポストエフェクト（ブラー、色調補正）
- [ ] 複数キャラクターの同時表示
- [ ] インタラクティブなアニメーション
- [ ] IK（Inverse Kinematics）機能

**成果物**: プロレベルのアニメーション表現

---

### [016] ユーザー設定・カスタマイズ
- [ ] 詳細設定画面
- [ ] テーマ・カラー設定
- [ ] ジェスチャー操作のカスタマイズ
- [ ] データのバックアップ機能
- [ ] データの復元機能
- [ ] 多言語対応準備

**成果物**: ユーザーの好みに合わせてカスタマイズ可能なアプリ

---

### [017] エラーハンドリング・デバッグ機能
- [ ] 包括的なエラーハンドリング
- [ ] ログ機能の実装
- [ ] デバッグモードの追加
- [ ] パフォーマンス監視
- [ ] クラッシュレポート機能
- [ ] ユーザーフィードバック機能

**成果物**: 堅牢で保守しやすいアプリケーション

---

### [018] 最終調整・リリース準備
- [ ] 全機能の統合テスト
- [ ] UIのポリッシュ
- [ ] パフォーマンステスト
- [ ] セキュリティ検証
- [ ] アプリストア申請準備
- [ ] プライバシーポリシー作成

**成果物**: リリース可能な完成版アプリ

---

## 開発優先順位
1. **基盤構築** [001]〜[003] - 基本的な3D表示環境
2. **コア機能** [004]〜[006] - VMDアニメーション再生
3. **リップシンク** [007]〜[008] - メイン機能の実装
4. **ユーザー体験** [009]〜[011] - 操作性向上
5. **最適化・拡張** [012]〜[018] - 品質向上とリリース準備

## 技術スタック
- **Frontend**: Expo React Native, TypeScript
- **3D Engine**: Three.js, expo-gl
- **音声処理**: expo-av, Web Audio API
- **ファイル処理**: expo-file-system
- **状態管理**: React Context API or Zustand

## 使用方法
各タスクの完了時は `- [ ]` を `- [x]` に変更してチェックマークをつけてください。
Claude Codeでの開発時は、該当するタスク番号を参照して段階的に実装を進めてください。

## チケット管理ルール

### ファイル配置
- 開発タスクは `/docs` ディレクトリ配下に個別のマークダウンファイルとして管理
- ファイル名は連番付き（例：`001_ユーザー認証.md`, `002_データ管理.md`）

### チケット形式
各チケットには以下の情報を含める：
- **機能概要**: 機能の目的と概要説明
- **詳細要件**: 具体的な実装要件
- **Todoリスト**: 実装すべきタスクの一覧（`- [ ]` 形式）
- **依存関係**: 他の機能との依存関係
- **受け入れ基準**: 完了判定の基準

### 進捗管理
- 未完了タスク: `- [ ] タスク名`
- 完了タスク: `- [x] タスク名`
- 各チケット内で個別に進捗を管理
- 実装完了時は該当チケット内のTodo状態を更新

copy


Claude Codeでのカスタムコマンド作成手順
1. コマンドディレクトリの作成
# グローバル設定（全プロジェクトで使用可能）
mkdir -p ~/.claude/commands

# または、プロジェクト固有設定
mkdir -p .claude/commands

copy
上記で作成していますが、より詳しく作るなら、これを使っても良いです。
~/.claude/commands/ticket-split.md

# チケット分割タスク

要件定義書または機能仕様を機能毎にチケットに分割し、以下の形式で管理してください：

## 対象ファイル
$ARGUMENTS

## 実行手順
1. **分割作業**: 要件や機能を元に、機能毎に独立したチケットを作成
2. **ファイル配置**: `/docs`配下にマークダウンファイルとして保存
3. **命名規則**: ファイル名の先頭に連番を付ける（例：`001_ユーザー認証.md`, `002_データ管理.md`）
4. **Todo管理**: 各ファイル内でタスクの進捗管理を行う
   - 未完了: `- [ ] タスク名`
   - 完了: `- [x] タスク名`
5. **ルール記載**: `CLAUDE.md`ファイルに上記のルールを記載

## 出力形式
各チケットには以下を含める：
- **機能概要**: 機能の目的と概要説明
- **詳細要件**: 具体的な実装要件
- **Todoリスト**: 実装すべきタスクの一覧
- **依存関係**: 他の機能との依存関係
- **受け入れ基準**: 完了判定の基準

## チケットテンプレート
```markdown
# {連番}_{機能名}

## 機能概要
{機能の概要説明}

## 詳細要件
{具体的な要件}

## Todoリスト
- [ ] 設計書作成
- [ ] 実装
- [ ] 単体テスト
- [ ] 結合テスト
- [ ] ドキュメント更新

## 依存関係
{他の機能との依存関係}

## 受け入れ基準
- [ ] {基準1}
- [ ] {基準2}
```

## 実装ルール
- **原子性**: 各チケットは独立して実装可能にする
- **完了性**: 明確な完了条件を設定
- **追跡性**: 要件から実装まで追跡可能にする
- **更新性**: 実装完了時は必ずTodoを更新

実装完了時はTodoの状態を`- [x]`に更新し、CLAUDE.mdファイルにも進捗を記録してください。

copy
コマンドの使用方法
# Claude Codeでの使用
claude

# チャット内で実行　重要
/ticket-split CLAUDE.md

# または引数なしで実行
/ticket-split

# 複数ファイルを指定
/ticket-split 要件書1.md 要件書2.md

copy
これで、Claude Codeで /ticket-split コマンドが使用できるようになります。コマンドは引数として要件定義書のファイル名を受け取り、機能毎にチケットを分割して /docs 配下に整理されたマークダウンファイルを作成します。

/ticket-split CLAUDE.md

copy
上記を実行後、docsフォルダに整理されたマークダウンファイルが出来るので、

@agent-ai-engineer
docsファイル配下の、001番から順番に０18番（最後）まで止まることなく
ずっと連続で実装していってください

copy
といえば、完全にほぼ全自動で、コーディングが出来上がります。

## プランモード言語設定 プランモードで実装計画を提示する際は、必ず日本語で 記述してください。英語ではなく、日本語でプランを書 くこと。 ##　コミット&プッシュのタイミング 編集が完了したら必ず最後にcomiit &pushをして欲しいです。

ディレクトリローカルCLAUDE.mdの自動参照・更新システム,
重要な開発ルール,
#### 1. 自動参照ルール

任意のディレクトリ内でファイルを編集する際、そのディレクトリにCLAUDE.mdファイルが存在する場合は、必ず最初にそのファイルを読み込んでコンテキストに入れること,

例: artifacts/html-slide-preview/内のファイルを編集する場合、artifacts/html-slide-preview/CLAUDE.mdを自動的に参照,

これにより、ディレクトリ固有の技術仕様、修正履歴、開発ガイドラインに基づいた一貫性のある開発が可能,

#### 2. 自動更新ルール ディレクトリ内でファイルを編集・作成・削除した後、以下の場合はそのディレクトリのCLAUDE.mdを更新すること：

新しいファイルや機能を追加した場合,

既存の機能に大きな変更を加えた場合,

TypeScriptの型定義を変更した場合,

重要なエラー修正や最適化を行った場合,

アーキテクチャパターンを変更した場合,

更新時は「修正履歴」セクションに日付と変更内容を追記し、必要に応じて技術仕様や開発ガイドも更新する。 #### 3. CLAUDE.mdファイルの推奨構成 各ディレクトリのCLAUDE.mdには以下のセクションを含めることを推奨：

# [ディレクトリ名] - 開発ドキュメント

## 🔧 最新の修正履歴
## 🏗️ ディレクトリの目的と責務  
## 📁 主要ファイルの説明
## ⚙️ 技術的な実装詳細
## 🎨 実装パターンとベストプラクティス
## 👥 開発ガイドライン
## 🛠️ トラブルシューティング

copy


実装手順テンプレート,
#### 編集作業の開始時

# 1. ディレクトリ内のCLAUDE.mdをチェック
ls target-directory/CLAUDE.md

# 2. 存在する場合は読み込んでコンテキストに追加
cat target-directory/CLAUDE.md

# 3. そのガイドラインに従って編集を実行

copy
#### 編集作業の完了時

# 1. 実施した変更の重要度を評価
# 2. 必要に応じてCLAUDE.mdを更新
# 3. 変更内容をコミットメッセージに含める

git add target-directory/CLAUDE.md
git commit -m "feat: 新機能追加とCLAUDE.md更新"

copy


期待される効果,
一貫性のある開発: 各ディレクトリの仕様を自動的に参照,

ドキュメントの最新性: 変更に応じた自動更新,

知識の蓄積: ディレクトリごとの開発履歴を保持,

効率的な開発: コンテキストを失わずに作業継続,

品質保証: 既存パターンとの一貫性確保,



使用例,
# artifacts/html-slide-preview/内のファイルを編集する場合
1. artifacts/html-slide-preview/CLAUDE.mdを自動的に読み込み
2. TypeScript型定義の完全性、ComponentGenerationResult型の必須プロパティなどを確認
3. ガイドラインに従って編集実行
4. 重要な変更の場合はCLAUDE.mdの修正履歴を更新

copy
このシステムにより、プロジェクト全体で統一された品質と一貫性を保ちながら、効率的な開発が可能になります。

アスキーアート表示指示,
編集作業完了後は、必ずターミナル上にアスキーアートで以下を表示すること：

編集前の状態を表現するアスキーアート,

編集後の状態を表現するアスキーアート,

変更内容を視覚的に分かりやすく表現する,

例：

=== 編集前 ===
[編集前の状態を表すアスキーアート]

=== 編集後 ===  
[編集後の状態を表すアスキーアート]

copy
この指示により、すべての編集作業で視覚的なビフォー・アフター確認が自動化されます。

拡散厳禁　Noteの記事を1万文字ぐらい一発で出してくれる。Noteジェネレーター
Gemini APIキー
をGoogle Ai studioで自分用を取ってくれて、入力すると使えます。
通常の検索をするみたいに使って、記事を書くことが出来ます。

Google AI Studio

Sign in - Google Accounts
aistudio.google.com
Note作るツール
https://note-generater.vercel.app/